using Content.Client._Mono.Radar;
using Content.Client.Resources;
using Content.Client.Shuttles.Systems;
using Content.Client.Station; // Frontier
using Content.Shared._Crescent.ShipShields;
using Content.Shared._Lua.Shuttles.Components;
using Content.Shared._Mono.Company;
using Content.Shared._Mono.Detection;
using Content.Shared._Mono.Ships.Components;
using Content.Shared._NF.Shipyard.Prototypes;
using Content.Shared.Shuttles.BUIStates;
using Content.Shared.Shuttles.Components;
using Content.Shared.Shuttles.Systems;
using Content.Shared.Station.Components;
using JetBrains.Annotations;
using Robust.Client.AutoGenerated;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.XAML;
using Robust.Shared.Input;
using Robust.Shared.Map;
using Robust.Shared.Map.Components;
using Robust.Shared.Physics;
using Robust.Shared.Physics.Collision.Shapes;
using Robust.Shared.Physics.Components;
using Robust.Shared.Prototypes;
using System.Numerics;

namespace Content.Client.Shuttles.UI;

[GenerateTypedNameReferences]
[Virtual]
public partial class ShuttleNavControl : BaseShuttleControl // Mono
{
    [Dependency] private readonly IMapManager _mapManager = default!;
    [Dependency] private readonly IUserInterfaceManager _uiManager = default!;
    private readonly DetectionSystem _detection; // Mono
    private readonly SharedShuttleSystem _shuttles;
    private readonly SharedTransformSystem _transform;
    private readonly IFFDecryptionSystem _iffDecrypt; // Lua Decrypt mod
    private readonly Font _cipherFont; // Lua Decrypt mod
    private readonly Texture _vesselMicroIcon; // Lua vessel blip
    private readonly Texture _vesselSmallIcon; // Lua vessel blip
    private readonly Texture _vesselMediumIcon; // Lua vessel blip
    private readonly Texture _vesselLargeIcon; // Lua vessel blip
    private readonly Texture _unknownVesselIcon; // Lua vessel blip
    private const char CipherStart = '\uE000'; // Lua Decrypt mod
    private const char CipherEnd = '\uE001'; // Lua Decrypt mod
    private const float CipherScale = 0.7f; // Lua Decrypt mod (scale text)

    /// <summary>
    /// Used to transform all of the radar objects. Typically is a shuttle console parented to a grid.
    /// </summary>
    protected EntityCoordinates? _coordinates; // Mono

    /// <summary>
    /// Entity of controlling console
    /// </summary>
    private EntityUid? _consoleEntity;

    protected Angle? _rotation; // Mono

    private Dictionary<NetEntity, List<DockingPortState>> _docks = new();
    private readonly Dictionary<string, Color> _companyColorCache = new();

    public bool ShowIFF { get; set; } = true;
    public bool ShowIFFShuttles { get; set; } = true;
    public bool ShowDocks { get; set; } = true;
    public bool RotateWithEntity { get; set; } = true;

    /// <summary>
    ///   If present, called for every IFF. Must determine if it should or should not be shown.
    /// </summary>
    public Func<EntityUid, MapGridComponent, IFFComponent?, bool>? IFFFilter { get; set; } = null;

    /// <summary>
    /// Raised if the user left-clicks on the radar control with the relevant entitycoordinates.
    /// </summary>
    public Action<EntityCoordinates>? OnRadarClick;

    private List<Entity<MapGridComponent>> _grids = new();
    private List<Content.Shared.Shuttles.UI.MapObjects.ShuttleExclusionObject>? _radarExclusions; // Lua
    public ShuttleNavControl() : this(64f, 256f, 256f) { } // Mono

    public ShuttleNavControl(float minRange, float maxRange, float range) : base(minRange, maxRange, range) // Mono
    {
        RobustXamlLoader.Load(this);
        _detection = EntManager.System<DetectionSystem>(); // Mono
        _shuttles = EntManager.System<SharedShuttleSystem>();
        _transform = EntManager.System<SharedTransformSystem>();
        _iffDecrypt = EntManager.System<IFFDecryptionSystem>(); // Lua Decrypt mod
        var cache = IoCManager.Resolve<IResourceCache>(); // Lua
        _cipherFont = cache.GetFont("/Fonts/Drakkhen/drakkhen_beta.ttf", 12); // Lua Decrypt mod
        _vesselMicroIcon = cache.GetTexture("/Textures/_Lua/Interface/Radar/micro_white.png"); // Lua vessel blip
        _vesselSmallIcon = cache.GetTexture("/Textures/_Lua/Interface/Radar/light_white.png"); // Lua vessel blip
        _vesselMediumIcon = cache.GetTexture("/Textures/_Lua/Interface/Radar/medium_white.png"); // Lua vessel blip
        _vesselLargeIcon = cache.GetTexture("/Textures/_Lua/Interface/Radar/large_white.png"); // Lua vessel blip
        _unknownVesselIcon = cache.GetTexture("/Textures/_Lua/Interface/Radar/unknown.png"); // Lua vessel blip
        _station = EntManager.System<StationSystem>(); // Frontier
        _blips = EntManager.System<RadarBlipsSystem>();

        OnMouseEntered += HandleMouseEntered;
        OnMouseExited += HandleMouseExited;
    }

    private double _pruneAccumSeconds;
    public void SetMatrix(EntityCoordinates? coordinates, Angle? angle)
    {
        _coordinates = coordinates;
        _rotation = angle;
    }

    public void SetConsole(EntityUid? consoleEntity)
    {
        _consoleEntity = consoleEntity;
    }

    protected override void KeyBindUp(GUIBoundKeyEventArgs args)
    {
        base.KeyBindUp(args);

        // Frontier: Clicking coordinates
        if (args.Function != EngineKeyFunctions.UIClick)
            return;

        _isMouseDown = false;

        if (_coordinates == null || _rotation == null || OnRadarClick == null)
            return;
        // End Frontier

        var a = InverseScalePosition(args.RelativePosition);
        var relativeWorldPos = a with { Y = -a.Y };
        relativeWorldPos = _rotation.Value.RotateVec(relativeWorldPos);
        var coords = _coordinates.Value.Offset(relativeWorldPos);
        OnRadarClick?.Invoke(coords);
    }

    /// <summary>
    /// Gets the entity coordinates of where the mouse position is, relative to the control.
    /// </summary>
    [PublicAPI]
    public EntityCoordinates GetMouseCoordinatesFromCenter()
    {
        if (_coordinates == null || _rotation == null)
        {
            return EntityCoordinates.Invalid;
        }

        var pos = _uiManager.MousePositionScaled.Position - GlobalPosition;
        var relativeWorldPos = _rotation.Value.RotateVec(pos);

        // I am not sure why the resulting point is 20 units under the mouse.
        return _coordinates.Value.Offset(relativeWorldPos);
    }

    public void UpdateState(NavInterfaceState state)
    {
        SetMatrix(EntManager.GetCoordinates(state.Coordinates), state.Angle);

        WorldMaxRange = state.MaxRange;

        if (WorldMaxRange < WorldRange)
        {
            ActualRadarRange = WorldMaxRange;
        }

        if (WorldMaxRange < WorldMinRange)
            WorldMinRange = WorldMaxRange;

        ActualRadarRange = Math.Clamp(ActualRadarRange, WorldMinRange, WorldMaxRange);

        RotateWithEntity = state.RotateWithEntity;

        _docks = state.Docks;

        _radarExclusions = state.Exclusions; // Lua

        NFUpdateState(state); // Frontier Update State
    }

    protected override void Draw(DrawingHandleScreen handle)
    {
        //UseCircleMaskShader(handle); // Mono use, Lua no use

        base.Draw(handle);
        _pruneAccumSeconds += Timing.FrameTime.TotalSeconds;
        if (_pruneAccumSeconds >= 5.0)
        {
            _pruneAccumSeconds = 0;
            var toRemove = new List<EntityUid>();
            foreach (var kvp in GridData)
            { if (!EntManager.EntityExists(kvp.Key)) toRemove.Add(kvp.Key); }
            foreach (var uid in toRemove) GridData.Remove(uid);
        }

        DrawBacking(handle);
        DrawCircles(handle);

        // No data
        if (_coordinates == null || _rotation == null)
        {
            return;
        }

        var xformQuery = EntManager.GetEntityQuery<TransformComponent>();
        var fixturesQuery = EntManager.GetEntityQuery<FixturesComponent>();
        var bodyQuery = EntManager.GetEntityQuery<PhysicsComponent>();

        if (!xformQuery.TryGetComponent(_coordinates.Value.EntityId, out var xform)
            || xform.MapID == MapId.Nullspace)
        {
            return;
        }

        var mapPos = _transform.ToMapCoordinates(_coordinates.Value);
        var posMatrix = Matrix3Helpers.CreateTransform(_coordinates.Value.Position, _rotation.Value);
        var ourEntRot = RotateWithEntity ? _transform.GetWorldRotation(xform) : _rotation.Value;
        var ourEntMatrix = Matrix3Helpers.CreateTransform(_transform.GetWorldPosition(xform), ourEntRot);
        var shuttleToWorld = Matrix3x2.Multiply(posMatrix, ourEntMatrix);
        Matrix3x2.Invert(shuttleToWorld, out var worldToShuttle);
        var shuttleToView = Matrix3x2.CreateScale(new Vector2(MinimapScale, -MinimapScale)) * Matrix3x2.CreateTranslation(MidPointVector);

        // Draw shields
        DrawShields(handle, xform, worldToShuttle);

        // Frontier Corvax: north line drawing
        var rot = ourEntRot + _rotation.Value;
        DrawNorthLine(handle, rot);

        // Draw our grid in detail
        // Lua mod start
        EntityUid? ourGridIdNullable = xform.GridUid;
        EntityUid ourGridId = default;
        var viewerCompanyName = string.Empty;
        if (ourGridIdNullable != null)
        {
            ourGridId = ourGridIdNullable.Value;
            if (EntManager.TryGetComponent(ourGridId, out CompanyComponent? ourCompany)) viewerCompanyName = ourCompany.CompanyName;
            if (EntManager.TryGetComponent<MapGridComponent>(ourGridId, out var ourGrid) && fixturesQuery.HasComponent(ourGridId))
            {
                var ourGridToWorld = _transform.GetWorldMatrix(ourGridId);
                var ourGridToShuttle = Matrix3x2.Multiply(ourGridToWorld, worldToShuttle);
                var ourGridToView = ourGridToShuttle * shuttleToView;
                var color = _shuttles.GetIFFColor(ourGridId, self: true);
                DrawGrid(handle, ourGridToView, (ourGridId, ourGrid), color);
                DrawDocks(handle, ourGridId, ourGridToView);
            }
        }
        // Lua mod end

        // Draw radar position on the station
        const float radarVertRadius = 2f;
        var radarPosVerts = new Vector2[]
        {
            ScalePosition(new Vector2(0f, -radarVertRadius)),
            ScalePosition(new Vector2(radarVertRadius / 2f, 0f)),
            ScalePosition(new Vector2(0f, radarVertRadius)),
            ScalePosition(new Vector2(radarVertRadius / -2f, 0f)),
        };

        handle.DrawPrimitives(DrawPrimitiveTopology.TriangleFan, radarPosVerts, Color.Lime);

        var viewBounds = new Box2Rotated(new Box2(-WorldRange, -WorldRange, WorldRange, WorldRange).Translated(mapPos.Position), rot, mapPos.Position);
        var viewAABB = viewBounds.CalcBoundingBox();
        // Lua start
        if (_radarExclusions != null)
        {
            foreach (var excl in _radarExclusions)
            {
                var coords = EntManager.GetCoordinates(excl.Coordinates);
                var mapCoords = _transform.ToMapCoordinates(coords);
                if (mapCoords.MapId != xform.MapID) continue;
                var enlarged = viewAABB.Enlarged(excl.Range);
                if (!enlarged.Contains(mapCoords.Position)) continue;
                var centerInView = Vector2.Transform(mapCoords.Position, worldToShuttle * shuttleToView);
                var radiusPixels = excl.Range * MinimapScale;
                var color = Color.Lime.WithAlpha(0.35f);
                handle.DrawCircle(centerInView, radiusPixels, color, false);
            }
        }
        // Lua end

        _grids.Clear();
        _mapManager.FindGridsIntersecting(xform.MapID, new Box2(mapPos.Position - MaxRadarRangeVector, mapPos.Position + MaxRadarRangeVector), ref _grids, approx: true, includeMap: false);

        // Frontier - collect blip location data outside foreach - more changes ahead
        var blipDataList = new List<BlipData>();

        // Draw other grids... differently
        foreach (var grid in _grids)
        {
            var gUid = grid.Owner;
            if ((ourGridIdNullable != null && gUid == ourGridId) || !fixturesQuery.HasComponent(gUid)) // Lua Decrypt mod
                continue;

            var gridBody = bodyQuery.GetComponent(gUid);
            EntManager.TryGetComponent<IFFComponent>(gUid, out var iff);

            if (!_shuttles.CanDraw(gUid, gridBody, iff))
                continue;

            var flags = iff?.Flags ?? IFFFlags.None; // Lua mod
            var hideLabel = (flags & IFFFlags.HideLabel) != 0x0; // Lua mod
            var hideLabelShuttle = (flags & IFFFlags.HideLabelShuttle) != 0x0; // Lua Decrypt mod
            var detectionLevel = _consoleEntity == null ? DetectionLevel.Detected : _detection.IsGridDetected(grid.Owner, _consoleEntity.Value);
            var blipOnly = detectionLevel != DetectionLevel.Detected; // don't show outline outside of detection radius even if IFF on

            // Lua company radar rules
            CompanyPrototype? companyProto = null;
            var targetCompanyName = string.Empty;
            var aliesToViewer = false;
            var allyByCompany = false;
            var showCompanyOnUnknownRadar = false;
            if (EntManager.TryGetComponent(gUid, out CompanyComponent? targetCompany) && !string.IsNullOrEmpty(targetCompany.CompanyName))
            {
                targetCompanyName = targetCompany.CompanyName;
                allyByCompany = !string.IsNullOrEmpty(viewerCompanyName) && viewerCompanyName == targetCompanyName;
                var prototypeManager = IoCManager.Resolve<IPrototypeManager>();
                if (prototypeManager.TryIndex<CompanyPrototype>(targetCompany.CompanyName, out companyProto) && companyProto != null)
                {
                    showCompanyOnUnknownRadar = companyProto.ShowCompanyRadar;
                    if (companyProto.AliesOnRadar && (string.IsNullOrEmpty(viewerCompanyName) || viewerCompanyName != targetCompany.CompanyName)) aliesToViewer = true;
                }
            }
            var effectiveHideLabelShuttle = hideLabelShuttle && !(companyProto?.AliesOnRadar == true && allyByCompany);
            var gridCenterMap = _transform.ToMapCoordinates(new EntityCoordinates(gUid, gridBody.LocalCenter)).Position;
            var worldDist = Vector2.Distance(gridCenterMap, mapPos.Position);
            var detected = detectionLevel != DetectionLevel.Undetected || (!hideLabel && !effectiveHideLabelShuttle) || (effectiveHideLabelShuttle && worldDist <= IFFDecryptionSystem.Range); // Lua Decrypt mod
            if (!detected) continue; // Lua Decrypt mod
            var beyondRadar = worldDist > CornerRadarRange;
            if (MaximumIFFDistance >= 0.0f && worldDist > MaximumIFFDistance) continue;

            Matrix3x2 curGridToWorld = default;
            Matrix3x2 curGridToView = default;
            var needGeometry = !beyondRadar && !blipOnly;
            if (needGeometry)
            {
                curGridToWorld = _transform.GetWorldMatrix(gUid);
                curGridToView = curGridToWorld * worldToShuttle * shuttleToView;
            }

            var labelColor = _shuttles.GetIFFColor(grid, self: false, iff);
            var coordColor = new Color(labelColor.R * 0.8f, labelColor.G * 0.8f, labelColor.B * 0.8f, 0.5f);

            // Others default:
            // Color.FromHex("#FFC000FF")
            // Hostile default: Color.Firebrick
            // Lua decrypt mod start
            string? labelName;
            bool cipherName = false;
            var unknownShuttle = false;
            if (effectiveHideLabelShuttle)
            {
                var realName = EntManager.TryGetComponent<MetaDataComponent>(gUid, out var meta) ? meta.EntityName : string.Empty;
                var viewerKey = ourGridIdNullable ?? gUid;
                var decrypt = _iffDecrypt.Get(viewerKey, gUid, realName, worldDist, hideLabel: true);
                if (decrypt.Phase == IFFDecryptPhase.Known)
                { labelName = decrypt.Revealed; }
                else if (decrypt.Phase == IFFDecryptPhase.Decrypting)
                {
                    labelName = string.Concat(decrypt.Revealed, CipherStart, decrypt.Cipher, CipherEnd);
                    cipherName = true;
                    unknownShuttle = true;
                }
                else
                {
                    labelName = Loc.GetString("shuttle-console-unknown");
                    unknownShuttle = true;
                }
                if (showCompanyOnUnknownRadar && companyProto != null)
                {
                    //labelColor = Color.FromSrgb(companyProto.Color);
                    coordColor = new Color(labelColor.R * 0.8f, labelColor.G * 0.8f, labelColor.B * 0.8f, 0.5f);
                    labelName = $"{labelName}\n{companyProto.Name}";
                }
                else if (unknownShuttle)
                {
                    labelColor = Color.White;
                    coordColor = new Color(1f, 1f, 1f, 0.5f);
                }
            }
            else if (hideLabel) { labelName = null; }
            else
            {
                if (aliesToViewer) { labelName = EntManager.TryGetComponent<MetaDataComponent>(gUid, out var meta) ? meta.EntityName : Loc.GetString("shuttle-console-unknown"); }
                else { labelName = _shuttles.GetIFFLabel(grid, self: false, iff) ?? Loc.GetString("shuttle-console-unknown"); }
            }
            // Lua decrypt mod end

            var isPlayerShuttle = iff != null && (iff.Flags & IFFFlags.IsPlayerShuttle) != 0x0;
            var shouldDrawIFF = ShowIFF && labelName != null;
            if (IFFFilter != null)
            {
                shouldDrawIFF &= IFFFilter(gUid, grid.Comp, iff);
            }
            if (isPlayerShuttle)
            {
                shouldDrawIFF &= ShowIFFShuttles;
            }

            //var mapCenter = curGridToWorld. * gridBody.LocalCenter;
            //shouldDrawIFF = NfCheckShouldDrawIffRangeCondition(shouldDrawIFF, mapCenter, curGridToWorld); // Frontier code
            // Frontier: range checks
            var gridMapPos = gridCenterMap;
            shouldDrawIFF = NFCheckShouldDrawIffRangeCondition(shouldDrawIFF, gridMapPos - mapPos.Position);
            // End Frontier

            // Frontier: IFF drawing functions
            // The actual position in the UI. We offset the matrix position to render it off by half its width
            // plus by the offset.
            var uiPosition = Vector2.Transform(gridCenterMap, worldToShuttle * shuttleToView) / UIScale;

            // Confines the UI position within the viewport.
            var uiXCentre = (int)Width / 2;
            var uiYCentre = (int)Height / 2;
            var uiXOffset = uiPosition.X - uiXCentre;
            var uiYOffset = uiPosition.Y - uiYCentre;
            var uiDistance = (int)Math.Sqrt(Math.Pow(uiXOffset, 2) + Math.Pow(uiYOffset, 2));
            var uiX = uiXCentre * uiXOffset / uiDistance;
            var uiY = uiYCentre * uiYOffset / uiDistance;

            var isOutsideRadarCircle = uiDistance > Math.Abs(uiX) && uiDistance > Math.Abs(uiY);
            if (isOutsideRadarCircle)
            {
                // 0.95f for offsetting the icons slightly away from edge of radar so it doesnt clip.
                uiX = uiXCentre * uiXOffset / uiDistance * 0.95f;
                uiY = uiYCentre * uiYOffset / uiDistance * 0.95f;
                uiPosition = new Vector2(
                    x: uiX + uiXCentre,
                    y: uiY + uiYCentre
                );
            }

            // Lua decrypt mod start
            var allowBlip = !hideLabel;
            if (effectiveHideLabelShuttle) allowBlip = true;
            Texture? vesselIcon = null;
            var blipScale = 1f;
            if (EntManager.TryGetComponent<VesselComponent>(gUid, out var vesselComp))
            {
                var prototypeManager = IoCManager.Resolve<IPrototypeManager>();
                if (vesselComp.VesselId != default && prototypeManager.TryIndex<VesselPrototype>(vesselComp.VesselId, out var vesselProto) && vesselProto != null)
                {
                    (blipScale, vesselIcon) = vesselProto.Category switch
                    {
                        VesselSize.Micro => (0.85f, _vesselMicroIcon),
                        VesselSize.Small => (1.0f, _vesselSmallIcon),
                        VesselSize.Medium => (1.2f, _vesselMediumIcon),
                        VesselSize.Large => (1.45f, _vesselLargeIcon),
                        _ => (1.0f, null)
                    };
                }
            }
            if (unknownShuttle) { vesselIcon = _unknownVesselIcon; blipScale = 1.6f; }
            var companyColorUid = (!aliesToViewer && !(unknownShuttle && !showCompanyOnUnknownRadar)) ? gUid : default;
            if (ShowIFF)
            {
                RadarBlipIconComponent? blipComp = null;
                var hasGridIcon = EntManager.TryGetComponent<RadarBlipIconComponent>(gUid, out var gridBlip) && gridBlip.Icon != default;
                if (hasGridIcon) blipComp = gridBlip;
                else if (EntManager.TryGetComponent<StationMemberComponent>(gUid, out var member) && EntManager.TryGetComponent<RadarBlipIconComponent>(member.Station, out var stationBlip) && stationBlip.Icon != default) blipComp = stationBlip;
                if (blipComp != null && blipComp.Icon != default)
                {
                    var canShow = true;
                    if (hideLabel && !blipComp.AllowWhenHidden) canShow = false;
                    if (blipComp.RequireDetection && detectionLevel == DetectionLevel.Undetected) canShow = false;
                    var beyondIconDistance = blipComp.MaxDistance > 0f && worldDist > blipComp.MaxDistance;
                    if (beyondIconDistance) canShow = false;
                    if (canShow)
                    {
                        var cache = IoCManager.Resolve<IResourceCache>();
                        if (cache.TryGetResource<TextureResource>(blipComp.Icon, out var texRes))
                        {
                            var tex = texRes.Texture;
                            var s = (RadarBlipSize * UIScale) * blipComp.Scale;
                            var half = new Vector2(s / 2f, s / 2f);
                            var box = new UIBox2(uiPosition * UIScale - half, uiPosition * UIScale + half);
                            handle.DrawTextureRect(tex, box, labelColor);
                        }
                        else if (allowBlip)
                        { NFAddBlipToList(blipDataList, isOutsideRadarCircle, uiPosition, uiXCentre, uiYCentre, labelColor, blipScale, companyColorUid); }
                    }
                    else if (!beyondIconDistance && allowBlip) { NFAddBlipToList(blipDataList, isOutsideRadarCircle, uiPosition, uiXCentre, uiYCentre, labelColor, blipScale, companyColorUid); }
                }
                else if (allowBlip && vesselIcon != null)
                {
                    var s = (RadarBlipSize * UIScale) * blipScale;
                    var half = new Vector2(s / 2f, s / 2f);
                    var box = new UIBox2(uiPosition * UIScale - half, uiPosition * UIScale + half);
                    handle.DrawTextureRect(vesselIcon, box, labelColor);
                }
                else if (allowBlip) { NFAddBlipToList(blipDataList, isOutsideRadarCircle, uiPosition, uiXCentre, uiYCentre, labelColor, blipScale, companyColorUid); }
            }
            if (shouldDrawIFF)
            { // Lua decrypt mod end
                var scaledMousePosition = GetMouseCoordinatesFromCenter().Position * UIScale;
                var isMouseOver = Vector2.Distance(scaledMousePosition, uiPosition * UIScale) < 30f;

                // Distant stations that are not player controlled ships
                var isDistantPOI = iff != null || (iff == null || (iff.Flags & IFFFlags.IsPlayerShuttle) == 0x0);

                var distance = worldDist;

                if (!isOutsideRadarCircle || isDistantPOI || isMouseOver)
                {
                    // Shows decimal when distance is < 50m, otherwise pointless to show it.
                    var displayedDistance = distance < 50f ? $"{distance:0.0}" : distance < 1000 ? $"{distance:0}" : $"{distance / 1000:0.0}k";
                    var labelText = Loc.GetString("shuttle-console-iff-label", ("name", labelName)!, ("distance", displayedDistance));

                    var coordsText = $"({gridMapPos.X:0.0}, {gridMapPos.Y:0.0})";

                    // Calculate unscaled offsets. + Lua decrypt md start
                    var lines = labelText.Split('\n');
                    var mainLabel = lines[0];
                    var mainDim = cipherName ? GetCipherDimensions(handle, mainLabel, 1f) : handle.GetDimensions(Font, mainLabel, 1f);
                    var labelDimensions = mainDim;
                    if (lines.Length > 1)
                    {
                        var otherDim = handle.GetDimensions(Font, lines[1], 1f);
                        labelDimensions = new Vector2(Math.Max(labelDimensions.X, otherDim.X), labelDimensions.Y + otherDim.Y);
                    }
                    // Lua decrypt mod end
                    var blipSize = RadarBlipSize * 0.7f;
                    var labelOffset = new Vector2()
                    {
                        X = uiPosition.X > Width / 2f
                            ? -labelDimensions.X - blipSize // right align the text to left of the blip
                            : blipSize, // left align the text to the right of the blip
                        Y = -labelDimensions.Y / 2f
                    };
                    var displayColor = labelColor;
                    if (!aliesToViewer && !(unknownShuttle && !showCompanyOnUnknownRadar) && EntManager.TryGetComponent(gUid, out CompanyComponent? companyComp) && !string.IsNullOrEmpty(companyComp.CompanyName))
                    {
                        if (!_companyColorCache.TryGetValue(companyComp.CompanyName, out var compColor))
                        {
                            var prototypeManager = IoCManager.Resolve<IPrototypeManager>();
                            if (prototypeManager.TryIndex<CompanyPrototype>(companyComp.CompanyName, out var prototype) && prototype != null)
                            {
                                compColor = prototype.Color;
                                _companyColorCache[companyComp.CompanyName] = compColor;
                            }
                        }
                        if (compColor != default)
                            displayColor = compColor;
                    }

                    if (cipherName) DrawCipherString(handle, (uiPosition + labelOffset) * UIScale, mainLabel, UIScale * 0.9f, displayColor); //Lua decrypt mod
                    else handle.DrawString(Font, (uiPosition + labelOffset) * UIScale, mainLabel, UIScale * 0.9f, displayColor); //Lua decrypt mod

                    // Draw company label if present
                    if (lines.Length > 1)
                    {
                        var companyLabel = lines[1];
                        var companyLabelOffset = new Vector2(
                            labelOffset.X,
                            labelOffset.Y + handle.GetDimensions(Font, mainLabel, 0.9f).Y
                        );

                        handle.DrawString(Font, (uiPosition + companyLabelOffset) * UIScale, companyLabel, UIScale * 0.9f, displayColor);
                    }

                    if (isMouseOver && !HideCoords)
                    {
                        var coordDimensions = handle.GetDimensions(Font, coordsText, 0.7f);
                        var coordOffset = new Vector2()
                        {
                            X = uiPosition.X > Width / 2f
                                ? -coordDimensions.X - blipSize / 0.7f // right align the text to left of the blip (0.7 needed for scale)
                                : blipSize, // left align the text to the right of the blip
                            Y = labelOffset.Y + handle.GetDimensions(Font, mainLabel, 1f).Y + (lines.Length > 1 ? handle.GetDimensions(Font, lines[1], 1f).Y : 0) + 5
                        };
                        handle.DrawString(Font, (uiPosition + coordOffset) * UIScale, coordsText, 0.7f * UIScale, coordColor);
                    }
                }

            }

            // Frontier Don't skip drawing blips if they're out of range.
            NFDrawBlips(handle, blipDataList);

            // Detailed view
            var gridAABB = curGridToWorld.TransformBox(grid.Comp.LocalAABB);

            // Skip drawing if it's out of range.
            if (beyondRadar || !gridAABB.Intersects(viewAABB)) continue;

            // Mono
            if (!blipOnly)
            {
                DrawGrid(handle, curGridToView, grid, labelColor);
                DrawDocks(handle, gUid, curGridToView);
            }
        }

        // Frontier: draw target
        if (!HideTarget && Target is { } target)
        {
            var targetEntity = EntManager.GetEntity(TargetEntity);

            string targetName;
            if (EntManager.TryGetComponent<MetaDataComponent>(targetEntity, out var targetMeta))
                targetName = targetMeta.EntityName;
            else
                targetName = Loc.GetString("shuttle-console-target-name");

            var curGridToView = Matrix3Helpers.CreateTranslation(target) * worldToShuttle * shuttleToView;

            var labelColor = TargetColor;
            var coordColor = new Color(TargetColor.R * 0.8f, TargetColor.G * 0.8f, TargetColor.B * 0.8f, 0.5f);

            //var gridCentre = Vector2.Transform(gridBody.LocalCenter, curGridToView);
            //gridCentre.Y = -gridCentre.Y;

            // Frontier: IFF drawing functions
            // The actual position in the UI. We offset the matrix position to render it off by half its width
            // plus by the offset.
            //var uiPosition = ScalePosition(gridCentre) / UIScale;
            var uiPosition = Vector2.Transform(Vector2.Zero, curGridToView) / UIScale;

            // Confines the UI position within the viewport.
            var uiXCentre = (int)Width / 2;
            var uiYCentre = (int)Height / 2;
            var uiXOffset = uiPosition.X - uiXCentre;
            var uiYOffset = uiPosition.Y - uiYCentre;
            var uiDistance = (int)Math.Sqrt(Math.Pow(uiXOffset, 2) + Math.Pow(uiYOffset, 2));
            var uiX = uiXCentre * uiXOffset / uiDistance;
            var uiY = uiYCentre * uiYOffset / uiDistance;

            var isOutsideRadarCircle = uiDistance > Math.Abs(uiX) && uiDistance > Math.Abs(uiY);
            if (isOutsideRadarCircle)
            {
                // 0.95f for offsetting the icons slightly away from edge of radar so it doesnt clip.
                uiX = uiXCentre * uiXOffset / uiDistance * 0.95f;
                uiY = uiYCentre * uiYOffset / uiDistance * 0.95f;
                uiPosition = new Vector2(
                    x: uiX + uiXCentre,
                    y: uiY + uiYCentre
                );
            }

            var scaledMousePosition = GetMouseCoordinatesFromCenter().Position * UIScale;
            var isMouseOver = Vector2.Distance(scaledMousePosition, uiPosition * UIScale) < 30f;

            var distance = Vector2.Distance(target, mapPos.Position);

            // Shows decimal when distance is < 50m, otherwise pointless to show it.
            var displayedDistance = distance < 50f ? $"{distance:0.0}" : distance < 1000 ? $"{distance:0}" : $"{distance / 1000:0.0}k";
            var labelText = Loc.GetString("shuttle-console-iff-label", ("name", targetName)!, ("distance", displayedDistance));

            var coordsText = $"({target.X:0.0}, {target.Y:0.0})";

            // Calculate unscaled offsets.
            var labelDimensions = handle.GetDimensions(Font, labelText, 1f);
            var blipSize = RadarBlipSize * 0.7f;
            var labelOffset = new Vector2()
            {
                X = uiPosition.X > Width / 2f
                    ? -labelDimensions.X - blipSize // right align the text to left of the blip
                    : blipSize, // left align the text to the right of the blip
                Y = -labelDimensions.Y / 2f
            };

            handle.DrawString(Font, (uiPosition + labelOffset) * UIScale, labelText, UIScale, labelColor);
            if (isMouseOver && !HideCoords)
            {
                var coordDimensions = handle.GetDimensions(Font, coordsText, 0.7f);
                var coordOffset = new Vector2()
                {
                    X = uiPosition.X > Width / 2f
                        ? -coordDimensions.X - blipSize / 0.7f // right align the text to left of the blip (0.7 needed for scale)
                        : blipSize, // left align the text to the right of the blip
                    Y = coordDimensions.Y / 2
                };
                handle.DrawString(Font, (uiPosition + coordOffset) * UIScale, coordsText, 0.7f * UIScale, coordColor);
            }

            NFAddBlipToList(blipDataList, isOutsideRadarCircle, uiPosition, uiXCentre, uiYCentre, labelColor, 1f, targetEntity ?? default); // Frontier code
            // End Frontier: IFF drawing functions
        }

        // Draw all blips on the map at this point.
        NFDrawBlips(handle, blipDataList);
        // End Frontier: draw target

        // If we've set the controlling console, and it's on a different grid
        // to the shuttle itself, then draw an additional marker to help the
        // player determine where they are relative to the shuttle.
        if (_consoleEntity != null && xformQuery.TryGetComponent(_consoleEntity, out var consoleXform))
        {
            if (consoleXform.ParentUid != _coordinates.Value.EntityId)
            {
                var consolePositionWorld = _transform.GetWorldPosition((EntityUid)_consoleEntity);
                var p = Vector2.Transform(consolePositionWorld, worldToShuttle * shuttleToView);
                handle.DrawCircle(p, 5, Color.ToSrgb(Color.Cyan), true);
            }
        }

        #region Mono
        // Draw radar line
        // First, figure out which angle to draw.
        var updateRatio = _updateAccumulator / RadarUpdateInterval;

        Angle angle = updateRatio * Math.Tau;
        var origin = ScalePosition(-new Vector2(Offset.X, -Offset.Y));
        handle.DrawLine(origin, origin + angle.ToVec() * ScaledMinimapRadius * 1.42f, Color.Red.WithAlpha(0.1f));

        // Get blips
        var rawBlips = _blips.GetCurrentBlips();
        const int MaxBlipsDraw = 320;
        var blipStride = Math.Max(1, rawBlips.Count / MaxBlipsDraw);

        // Prepare view bounds for culling
        var monoViewBounds = new Box2(-3f, -3f, Size.X + 3f, Size.Y + 3f);

        // Draw blips using the same grid-relative transformation approach as docks
        foreach (var blip in rawBlips)
        {
            var blipMap = _transform.ToMapCoordinates(blip.Position);
            if (blipMap.MapId != xform.MapID) continue;
            if (Vector2.Distance(blipMap.Position, mapPos.Position) > CornerRadarRange) continue;
            var blipPosInView = Vector2.Transform(blipMap.Position, worldToShuttle * shuttleToView);

            // Check if this blip is within view bounds before drawing
            if (monoViewBounds.Contains(blipPosInView))
            {
                DrawBlipShape(handle, blipPosInView, blip.Scale * 3f, blip.Color.WithAlpha(0.8f), blip.Shape);
            }
        }

        // Draw hitscan lines from the radar blips system
        var hitscanLines = _blips.GetHitscanLines();
        foreach (var line in hitscanLines)
        {
            var startPosInView = Vector2.Transform(line.Start, worldToShuttle * shuttleToView);
            var endPosInView = Vector2.Transform(line.End, worldToShuttle * shuttleToView);

            // Only draw lines if at least one endpoint is within view
            if (monoViewBounds.Contains(startPosInView) || monoViewBounds.Contains(endPosInView))
            {
                // Draw the line with the specified thickness and color
                handle.DrawLine(startPosInView, endPosInView, line.Color);

                // For thicker lines, draw multiple lines side by side
                if (line.Thickness > 1.0f)
                {
                    // Calculate perpendicular vector for thickness
                    var dir = (endPosInView - startPosInView).Normalized();
                    var perpendicular = new Vector2(-dir.Y, dir.X) * 0.5f;

                    // Draw additional lines for thickness
                    for (float i = 1; i <= line.Thickness; i += 1.0f)
                    {
                        var offset = perpendicular * i;
                        handle.DrawLine(startPosInView + offset, endPosInView + offset, line.Color);
                        handle.DrawLine(startPosInView - offset, endPosInView - offset, line.Color);
                    }
                }
            }
        }

        ClearShader(handle);
        #endregion
    }

    private void DrawDocks(DrawingHandleScreen handle, EntityUid uid, Matrix3x2 gridToView)
    {
        if (!ShowDocks)
            return;

        const float DockScale = 0.6f;
        var nent = EntManager.GetNetEntity(uid);

        const float sqrt2 = 1.41421356f;
        const float dockRadius = DockScale * sqrt2;
        // Worst-case bounds used to cull a dock:
        Box2 viewBounds = new Box2(
            -dockRadius * UIScale,
            -dockRadius * UIScale,
            (Size.X + dockRadius) * UIScale,
            (Size.Y + dockRadius) * UIScale);

        if (_docks.TryGetValue(nent, out var docks))
        {
            foreach (var state in docks)
            {
                var position = state.Coordinates.Position;

                var positionInView = Vector2.Transform(position, gridToView);
                if (!viewBounds.Contains(positionInView))
                {
                    continue;
                }

                //var color = Color.ToSrgb(Color.Magenta); // Frontier
                var color = Color.ToSrgb(state.HighlightedRadarColor); // Frontier

                var verts = new[]
                {
                    Vector2.Transform(position + new Vector2(-DockScale, -DockScale), gridToView),
                    Vector2.Transform(position + new Vector2(DockScale, -DockScale), gridToView),
                    Vector2.Transform(position + new Vector2(DockScale, DockScale), gridToView),
                    Vector2.Transform(position + new Vector2(-DockScale, DockScale), gridToView),
                };

                handle.DrawPrimitives(DrawPrimitiveTopology.TriangleFan, verts, color.WithAlpha(0.8f));
                handle.DrawPrimitives(DrawPrimitiveTopology.LineStrip, verts, color);
            }

            // Frontier: draw dock labels (done last to appear on top of all docks, still fights with other grids)
            var labeled = new HashSet<string>();
            foreach (var state in docks)
            {
                if (state.LabelName == null || labeled.Contains(state.LabelName))
                    continue;

                var position = state.Coordinates.Position;
                var uiPosition = Vector2.Transform(position, gridToView);

                if (!viewBounds.Contains(uiPosition))
                    continue;

                labeled.Add(state.LabelName);
                var labelDimensions = handle.GetDimensions(Font, state.LabelName, 0.9f);
                handle.DrawString(Font, (uiPosition / UIScale - labelDimensions / 2) * UIScale, state.LabelName, UIScale * 0.9f, _dockLabelColor);
            }
            // End Frontier
        }
    }

    protected Vector2 InverseScalePosition(Vector2 value)
    {
        // Account for UI scaling: value is unscaled, so adjust by UIScale
        var scaledValue = value * UIScale;
        return (scaledValue - MidPointVector) / MinimapScale;
    }

    public class BlipData
    {
        public bool IsOutsideRadarCircle { get; set; }
        public Vector2 UiPosition { get; set; }
        public Vector2 VectorToPosition { get; set; }
        public Color Color { get; set; }
        public float Scale { get; set; } = 1f;
    }

    private const int RadarBlipSize = 15;
    private const int RadarFontSize = 8;

    private void DrawShields(DrawingHandleScreen handle, TransformComponent consoleXform, Matrix3x2 matrix)
    {
        var shields = EntManager.AllEntityQueryEnumerator<ShipShieldVisualsComponent, FixturesComponent, TransformComponent>();
        var consoleWorldPos = _transform.GetWorldPosition(consoleXform);
        while (shields.MoveNext(out var uid, out var visuals, out var fixtures, out var xform))
        {
            if (!EntManager.TryGetComponent<TransformComponent>(xform.GridUid, out var parentXform))
                continue;

            if (xform.MapID != consoleXform.MapID)
                continue;

            // Don't draw shields when in FTL
            if (EntManager.HasComponent<FTLComponent>(parentXform.Owner)) continue;
            var shieldWorldPos = _transform.GetWorldPosition(parentXform);
            if (Vector2.Distance(shieldWorldPos, consoleWorldPos) > CornerRadarRange) continue;
            var detectionLevel = _consoleEntity == null ? DetectionLevel.Detected : _detection.IsGridDetected(parentXform.Owner, _consoleEntity.Value);
            if (detectionLevel != DetectionLevel.Detected)
                continue;

            var shieldFixture = fixtures.Fixtures.TryGetValue("shield", out var fixture) ? fixture : null;

            if (shieldFixture == null || shieldFixture.Shape is not ChainShape)
                continue;

            ChainShape chain = (ChainShape)shieldFixture.Shape;

            var count = chain.Count;
            var verticies = chain.Vertices;

            const int MaxSegments = 1000;
            var stride = Math.Max(1, count / MaxSegments);

            var center = xform.LocalPosition;

            for (int i = 1; i < count; i++)
            {
                var v1 = Vector2.Add(center, verticies[i - 1]);
                v1 = Vector2.Transform(v1, parentXform.WorldMatrix); // transform to world matrix
                v1 = Vector2.Transform(v1, matrix); // get back to local matrix for drawing
                v1.Y = -v1.Y;
                v1 = ScalePosition(v1);
                var nextIndex = Math.Min(i, count - 1);
                var v2 = Vector2.Add(center, verticies[nextIndex]);
                v2 = Vector2.Transform(v2, parentXform.WorldMatrix);
                v2 = Vector2.Transform(v2, matrix);
                v2.Y = -v2.Y;
                v2 = ScalePosition(v2);
                handle.DrawLine(v1, v2, visuals.ShieldColor);
            }
        }
    }

    // Lua decrypt mod start
    private Vector2 GetCipherDimensions(DrawingHandleScreen handle, string text, float scale)
    {
        if (!TrySplitCipher(text, out var pre, out var cipher, out var post)) return handle.GetDimensions(Font, text, scale);
        var d1 = string.IsNullOrEmpty(pre) ? Vector2.Zero : handle.GetDimensions(Font, pre, scale);
        var d2 = string.IsNullOrEmpty(cipher) ? Vector2.Zero : handle.GetDimensions(_cipherFont, cipher, scale * CipherScale);
        var d3 = string.IsNullOrEmpty(post) ? Vector2.Zero : handle.GetDimensions(Font, post, scale);
        return new Vector2(d1.X + d2.X + d3.X, MathF.Max(d1.Y, MathF.Max(d2.Y, d3.Y)));
    }

    private void DrawCipherString(DrawingHandleScreen handle, Vector2 pos, string text, float scale, Color color)
    {
        if (!TrySplitCipher(text, out var pre, out var cipher, out var post))
        { handle.DrawString(Font, pos, text.Replace(CipherStart.ToString(), string.Empty).Replace(CipherEnd.ToString(), string.Empty), scale, color); return; }
        var x = 0f;
        if (!string.IsNullOrEmpty(pre))
        { handle.DrawString(Font, pos, pre, scale, color); x += handle.GetDimensions(Font, pre, scale).X; }
        if (!string.IsNullOrEmpty(cipher))
        {
            var s = scale * CipherScale;
            handle.DrawString(_cipherFont, pos + new Vector2(x, 0f), cipher, s, color);
            x += handle.GetDimensions(_cipherFont, cipher, s).X;
        }
        if (!string.IsNullOrEmpty(post))
        { handle.DrawString(Font, pos + new Vector2(x, 0f), post, scale, color); }
    }

    private static bool TrySplitCipher(string text, out string pre, out string cipher, out string post)
    {
        var i = text.IndexOf(CipherStart);
        if (i < 0)
        {
            pre = text;
            cipher = string.Empty;
            post = string.Empty;
            return false;
        }
        var j = text.IndexOf(CipherEnd, i + 1);
        if (j < 0)
        {
            pre = text.Replace(CipherStart.ToString(), string.Empty).Replace(CipherEnd.ToString(), string.Empty);
            cipher = string.Empty;
            post = string.Empty;
            return false;
        }
        pre = text[..i];
        cipher = text[(i + 1)..j];
        post = text[(j + 1)..];
        return true;
        // Lua decrypt mod end
    }
}
